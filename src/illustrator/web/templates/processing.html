{% extends "base.html" %}

{% block title %}Processing - Manuscript Illustrator{% endblock %}

{% block page_icon %}<i class="bi bi-gear-fill me-2"></i>{% endblock %}

{% block page_actions %}
<div class="btn-group" role="group">
    <button type="button" class="btn btn-outline-secondary" onclick="pauseProcessing()" id="pauseBtn" disabled>
        <i class="bi bi-pause"></i> Pause
    </button>
    <button type="button" class="btn btn-outline-warning" onclick="restartProcessing()" id="restartBtn">
        <i class="bi bi-arrow-clockwise"></i> Restart
    </button>
    <button type="button" class="btn btn-outline-danger" onclick="cancelProcessing()" id="cancelBtn" disabled>
        <i class="bi bi-stop"></i> Cancel
    </button>
    <a href="/manuscript/{{ manuscript_id }}" class="btn btn-outline-primary" onclick="enableBackgroundProcessing()">
        <i class="bi bi-arrow-left"></i> Back to Manuscript
    </a>
</div>
{% endblock %}

{% block breadcrumb %}
<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="/">Dashboard</a></li>
        <li class="breadcrumb-item"><a href="/manuscript/{{ manuscript_id }}">Manuscript</a></li>
        <li class="breadcrumb-item active">Processing</li>
    </ol>
</nav>
{% endblock %}

{% block content %}
<!-- Processing Status Overview -->
<div class="row mb-4">
    <div class="col-lg-10 offset-lg-1 col-xl-8 offset-xl-2">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h4 class="card-title mb-0 fw-bold section-title">
                    <i class="bi bi-activity me-2"></i>Processing Status
                </h4>
                <div class="d-flex align-items-center gap-2">
                    <div class="spinner-border spinner-border-sm text-primary me-2" role="status" id="processingSpinner">
                        <span class="visually-hidden">Processing...</span>
                    </div>
                    <span class="badge bg-primary" id="processingStatus">Initializing</span>
                    <button type="button" class="btn btn-sm btn-outline-primary d-none" id="restartBtn" onclick="restartProcessing()">
                        <i class="bi bi-arrow-clockwise me-1"></i>Restart
                    </button>
                </div>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-8">
                        <!-- Progress Bar -->
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <small class="fw-bold">Overall Progress</small>
                                <small id="progressPercent">0%</small>
                            </div>
                            <div class="progress">
                                <div class="progress-bar progress-bar-striped progress-bar-animated"
                                     role="progressbar"
                                     style="width: 0%"
                                     id="overallProgress">
                                </div>
                            </div>
                        </div>

                        <!-- Current Task -->
                        <div class="mb-3">
                            <h6 class="fw-bold section-title">Current Task:</h6>
                            <p class="mb-0" id="currentTask">Waiting to start...</p>
                        </div>

                        <!-- Processing Steps -->
                        <div class="mb-3">
                            <h6 class="fw-bold section-title">Processing Pipeline:</h6>
                            <div class="list-group" id="processingSteps">
                                <div class="list-group-item d-flex justify-content-between align-items-center">
                                    <div>
                                        <i class="bi bi-circle text-muted me-2"></i>
                                        Text Analysis & Scene Extraction
                                    </div>
                                    <small class="text-muted">Pending</small>
                                </div>
                                <div class="list-group-item d-flex justify-content-between align-items-center">
                                    <div>
                                        <i class="bi bi-circle text-muted me-2"></i>
                                        Prompt Engineering & Style Application
                                    </div>
                                    <small class="text-muted">Pending</small>
                                </div>
                                <div class="list-group-item d-flex justify-content-between align-items-center">
                                    <div>
                                        <i class="bi bi-circle text-muted me-2"></i>
                                        Image Generation
                                    </div>
                                    <small class="text-muted">Pending</small>
                                </div>
                                <div class="list-group-item d-flex justify-content-between align-items-center">
                                    <div>
                                        <i class="bi bi-circle text-muted me-2"></i>
                                        Quality Review & Output Organization
                                    </div>
                                    <small class="text-muted">Pending</small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="col-md-4">
                        <!-- Processing Stats -->
                        <div class="card processing-stats-card">
                            <div class="card-body">
                                <h5 class="card-title fw-bold section-title">Processing Statistics</h5>
                                <div class="row text-center g-3">
                                    <div class="col-6">
                                        <div class="fw-bold fs-4 text-primary" id="chaptersProcessed">0</div>
                                        <small class="text-muted d-block" id="chaptersLabel">Chapters Processed</small>
                                    </div>
                                    <div class="col-6">
                                        <div class="fw-bold fs-4 text-success" id="imagesGenerated">0</div>
                                        <small class="text-muted d-block">Images Generated</small>
                                    </div>
                                </div>
                                <hr>
                                <div class="row text-center">
                                    <div class="col-12">
                                        <div class="fw-bold text-info" id="elapsedTime">00:00:00</div>
                                        <small class="text-muted">Elapsed Time</small>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Session Info -->
                        <div class="card mt-3">
                            <div class="card-body">
                                <h5 class="card-title fw-bold section-title">Session Information</h5>
                                <div class="small">
                                    <div class="mb-1">
                                        <strong>Session ID:</strong>
                                        <code id="sessionId">Not started</code>
                                    </div>
                                    <div class="mb-1">
                                        <strong>Started:</strong>
                                        <span id="startTime">-</span>
                                    </div>
                                    <div class="mb-1">
                                        <strong>Status:</strong>
                                        <span id="connectionStatus" class="badge bg-secondary">Connecting</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Endpoint Pause Notification -->
<div class="row mb-4" id="endpointPauseAlert" style="display: none;">
    <div class="col-lg-10 offset-lg-1 col-xl-8 offset-xl-2">
        <div class="alert alert-warning alert-dismissible" role="alert">
            <div class="d-flex align-items-center">
                <i class="bi bi-exclamation-triangle-fill me-3 fs-4"></i>
                <div class="flex-grow-1">
                    <h5 class="alert-heading mb-1 section-title">AI Endpoint Temporarily Paused</h5>
                    <p class="mb-2" id="endpointPauseMessage">The AI service endpoint is currently paused. Waiting for it to restart automatically...</p>
                    <div class="d-flex align-items-center">
                        <div class="spinner-border spinner-border-sm text-warning me-2" role="status">
                            <span class="visually-hidden">Waiting...</span>
                        </div>
                        <strong id="countdownTimer">Retrying in 120 seconds...</strong>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Processing Log -->
<div class="row mb-4">
    <div class="col-lg-10 offset-lg-1 col-xl-8 offset-xl-2">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h4 class="card-title mb-0 fw-bold section-title">
                    <i class="bi bi-terminal me-2"></i>Processing Log
                </h4>
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-info text-white" onclick="toggleAutoScroll()" id="autoScrollBtn">
                        <i class="bi bi-arrow-down"></i> Auto-scroll
                    </button>
                    <button type="button" class="btn btn-primary" onclick="toggleMaximizeLog()" id="maximizeLogBtn">
                        <i class="bi bi-arrows-fullscreen"></i> Maximize
                    </button>
                    <button type="button" class="btn btn-warning" onclick="clearLog()">
                        <i class="bi bi-trash"></i> Clear
                    </button>
                </div>
            </div>
            <div class="card-body p-0">
                <div class="bg-dark text-light p-3" style="height: 300px; overflow-y: auto; font-family: monospace;" id="processingLog">
                    <div class="text-muted">Waiting for processing to start...</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Generated Images Preview -->
<div class="row" id="imagesPreview" style="display: none;">
    <div class="col-lg-10 offset-lg-1 col-xl-8 offset-xl-2">
        <div class="card">
            <div class="card-header">
                <h4 class="card-title mb-0 fw-bold section-title">
                    <i class="bi bi-images me-2"></i>Generated Images
                </h4>
            </div>
            <div class="card-body">
                <div class="row" id="imagesList">
                    <!-- Dynamic images will be added here -->
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Error Modal -->
<div class="modal fade" id="errorModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header bg-danger text-white">
                <h4 class="modal-title fw-bold section-title">
                    <i class="bi bi-exclamation-triangle me-2"></i>Processing Error
                </h4>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-danger mb-3" role="alert">
                    <strong>An error occurred during processing:</strong>
                </div>
                <pre id="errorDetails" class="bg-light p-3 rounded"></pre>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-warning" onclick="retryProcessing()">
                    <i class="bi bi-arrow-clockwise"></i> Retry
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let websocket = null;
let sessionId = null;
let startTime = null;
let autoScroll = true;
let processingInterval = null;
let reconnectAttempts = 0;
let maxReconnectAttempts = 10;
let reconnectInterval = null;
let initialProgressFetched = false;
let isStartingSession = false;
let processingStarted = false;
let processingCompleted = false;
let processingFailed = false;
const statsState = {
    currentChapter: null,
    chaptersProcessed: 0,
    totalChapters: null,
    imagesGenerated: 0
};

document.addEventListener('DOMContentLoaded', function() {
    initializeProcessing();
});

function normalizeCount(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }

    const numberValue = Number(value);
    if (Number.isFinite(numberValue)) {
        return Math.max(0, Math.floor(numberValue));
    }

    return null;
}

function updateProcessingStats(partial = {}) {
    const currentChapter = partial.currentChapter ?? partial.current_chapter;
    const chaptersProcessed = partial.chaptersProcessed ?? partial.chapters_processed;
    const totalChapters = partial.totalChapters ?? partial.total_chapters;
    const imagesGenerated = partial.imagesGenerated ?? partial.images_generated;

    const updates = {
        currentChapter: normalizeCount(currentChapter),
        chaptersProcessed: normalizeCount(chaptersProcessed),
        totalChapters: normalizeCount(totalChapters),
        imagesGenerated: normalizeCount(imagesGenerated)
    };

    Object.entries(updates).forEach(([key, value]) => {
        if (value !== undefined) {
            statsState[key] = value;
        }
    });

    const processedRaw = statsState.chaptersProcessed ?? statsState.currentChapter ?? 0;
    const processed = processedRaw ?? 0;
    const total = statsState.totalChapters;

    const chaptersEl = document.getElementById('chaptersProcessed');
    if (chaptersEl) {
        const processedDisplay = Number(processed).toLocaleString();
        if (total !== null && total > 0) {
            const totalDisplay = Number(total).toLocaleString();
            chaptersEl.textContent = `${processedDisplay} / ${totalDisplay}`;
        } else {
            chaptersEl.textContent = processedDisplay;
        }
    }

    const labelEl = document.getElementById('chaptersLabel');
    if (labelEl) {
        labelEl.textContent = 'Chapters Processed';
    }

    const imagesEl = document.getElementById('imagesGenerated');
    if (imagesEl) {
        const imagesDisplay = Number(statsState.imagesGenerated ?? 0).toLocaleString();
        imagesEl.textContent = imagesDisplay;
    }
}

async function initializeProcessing() {
    // Check if session ID is provided in URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const urlSessionId = urlParams.get('session_id');
    processingCompleted = false;
    
    // Enable background processing by default - this is a new feature
    // This means processing will continue even if the user navigates away from this page

    if (urlSessionId) {
        // Connect directly to the specified session
        sessionId = urlSessionId;
        addLogMessage('info', `Connecting to session ${sessionId}...`);

        // Try to fetch session status to validate it exists
        try {
            const statusResponse = await fetch('/api/process/status/{{ manuscript_id }}');
            if (statusResponse.ok) {
                const statusData = await statusResponse.json();

                if (statusData.active_session && statusData.active_session.session_id === sessionId) {
                    const session = statusData.active_session;

                    addLogMessage('info', 'Session found, restoring state...');

                    // Set session info
                    document.getElementById('sessionId').textContent = sessionId;

                    // Set start time if available
                    if (session.start_time) {
                        startTime = new Date(session.start_time);
                        document.getElementById('startTime').textContent = formatDateTime(startTime);
                    }

                // Restore session state
                if (session.status) {
                    const status = session.status;
                    updateProgress(status.progress, status.message);
                    updateProcessingStatus(status.status, status.message || status.status);
                    
                    updateProcessingStats({
                        current_chapter: status.current_chapter,
                        chapters_processed: status.chapters_processed,
                        total_chapters: status.total_chapters,
                        images_generated: status.images_generated
                    });
                }

                // Restore step status
                if (session.step_status) {
                    Object.keys(session.step_status).forEach(stepIndex => {
                        updateProcessingStep(parseInt(stepIndex), session.step_status[stepIndex]);
                    });
                }                    // Restore logs
                    if (session.logs && session.logs.length > 0) {
                        const log = document.getElementById('processingLog');
                        log.innerHTML = '';

                        session.logs.forEach(logEntry => {
                            restoreLogMessage(logEntry.timestamp, logEntry.level, logEntry.message);
                        });

                        addLogMessage('info', `Restored ${session.logs.length} log entries`);
                    }

                // Restore images
                if (session.images && session.images.length > 0) {
                    session.images.forEach(imageEntry => {
                        addGeneratedImage(imageEntry.url, imageEntry.prompt, true); // true = skip counter increment
                    });

                    // Set the image count directly
                    updateProcessingStats({ imagesGenerated: session.images.length });
                    addLogMessage('info', `Restored ${session.images.length} generated images`);
                }                    // Connect WebSocket for real-time updates
                    connectWebSocket();

                    // Start time tracking
                    startTimeTracking();

                    // Enable control buttons
                    document.getElementById('pauseBtn').disabled = false;
                    document.getElementById('cancelBtn').disabled = false;

                    addLogMessage('success', 'Successfully connected to existing session');
                    processingStarted = true;
                    return;
                } else {
                    addLogMessage('warning', 'Specified session not found, checking for other active sessions...');
                }
            }
        } catch (error) {
            console.error('Error validating session:', error);
            addLogMessage('warning', `Could not validate session ${sessionId}, checking for other active sessions...`);
        }
    }

    // First check if there's an existing processing session (original logic)
    try {
        const statusResponse = await fetch('/api/process/status/{{ manuscript_id }}');
        if (statusResponse.ok) {
            const statusData = await statusResponse.json();

            if (statusData.active_session) {
                // Reconnect to existing session
                sessionId = statusData.active_session.session_id;
                const session = statusData.active_session;

                addLogMessage('info', 'Reconnecting to existing processing session...');

                // Set session info
                document.getElementById('sessionId').textContent = sessionId;

                // Set start time if available
                if (session.start_time) {
                    startTime = new Date(session.start_time);
                    document.getElementById('startTime').textContent = formatDateTime(startTime);
                }

                // Restore session state
                if (session.status) {
                    const status = session.status;
                    updateProgress(status.progress, status.message);
                    updateProcessingStatus(status.status, status.message || status.status);
                    
                    updateProcessingStats({
                        current_chapter: status.current_chapter,
                        chapters_processed: status.chapters_processed,
                        total_chapters: status.total_chapters,
                        images_generated: status.images_generated
                    });
                }

                // Restore step status
                if (session.step_status) {
                    Object.keys(session.step_status).forEach(stepIndex => {
                        updateProcessingStep(parseInt(stepIndex), session.step_status[stepIndex]);
                    });
                }

                // Restore logs
                if (session.logs && session.logs.length > 0) {
                    // Clear the initial log and add preserved logs
                    const log = document.getElementById('processingLog');
                    log.innerHTML = '';

                    session.logs.forEach(logEntry => {
                        restoreLogMessage(logEntry.timestamp, logEntry.level, logEntry.message);
                    });

                    addLogMessage('info', `Restored ${session.logs.length} log entries from previous session`);
                }

                // Restore images
                if (session.images && session.images.length > 0) {
                    session.images.forEach(imageEntry => {
                        addGeneratedImage(imageEntry.url, imageEntry.prompt, true); // true = skip counter increment
                    });

                    // Set the image count directly
                    updateProcessingStats({ imagesGenerated: session.images.length });
                    addLogMessage('info', `Restored ${session.images.length} generated images from previous session`);
                }

                // Connect WebSocket for real-time updates
                connectWebSocket();

                // Start time tracking
                startTimeTracking();

                // Enable control buttons
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('cancelBtn').disabled = false;

                addLogMessage('success', 'Successfully reconnected to existing processing session with full state restoration');
                processingStarted = true;
                return;
            }
        }
    } catch (error) {
        console.error('Error checking existing session:', error);
        addLogMessage('warning', 'Could not check for existing session, starting new one');
    }

    // No existing session found, start new processing
    startProcessingRequest();
}

async function startProcessingRequest() {
    if (isStartingSession) {
        return;
    }

    isStartingSession = true;
    try {
        // First, load the saved style configuration
        const styleResponse = await fetch('/api/manuscripts/{{ manuscript_id }}/style');
        let styleConfig = null;

        if (styleResponse.ok) {
            const styleData = await styleResponse.json();
            styleConfig = styleData.style_config;
        }

        // If no style config is saved, use defaults
        if (!styleConfig) {
            styleConfig = {
                image_provider: "imagen4",
                art_style: "digital painting"
            };
            addLogMessage('warning', 'No style configuration found. Using default settings.');
        }

        const response = await fetch('/api/process', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                manuscript_id: '{{ manuscript_id }}',
                style_config: styleConfig,
                max_emotional_moments: 10
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();

        if (result.success) {
            sessionId = result.session_id;
            startTime = new Date(result.started_at);

            document.getElementById('sessionId').textContent = sessionId;
            document.getElementById('startTime').textContent = formatDateTime(startTime);

            updateProcessingStats({
                currentChapter: 0,
                chaptersProcessed: 0,
                totalChapters: null,
                imagesGenerated: 0
            });

            // Connect WebSocket for real-time updates
            connectWebSocket();

            // Start time tracking
            startTimeTracking();

            // Enable control buttons
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('cancelBtn').disabled = false;

            if (result.is_existing) {
                addLogMessage('info', 'Reconnected to existing processing session');
            } else {
                addLogMessage('info', 'Processing session started successfully');
            }
            processingStarted = true;
            processingCompleted = false;
            processingFailed = false;
        } else {
            throw new Error(result.message || 'Failed to start processing');
        }
    } catch (error) {
        console.error('Error starting processing:', error);
        addLogMessage('error', `Failed to start processing: ${error.message}`);
        updateProcessingStatus('error', 'Failed to Start');
        processingStarted = false;
        processingFailed = true;
    }
    isStartingSession = false;
}

function connectWebSocket() {
    if (!sessionId) {
        console.error('No session ID available for WebSocket connection');
        return;
    }

    // Clear any existing reconnect interval
    if (reconnectInterval) {
        clearInterval(reconnectInterval);
        reconnectInterval = null;
    }

    const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/processing/${sessionId}`;

    websocket = new WebSocket(wsUrl);

    websocket.onopen = function(event) {
        console.log('WebSocket connection established');
        reconnectAttempts = 0; // Reset reconnect attempts on successful connection
        document.getElementById('connectionStatus').textContent = 'Connected';
        document.getElementById('connectionStatus').className = 'badge bg-success';
        addLogMessage('info', 'Connected to processing server');
        
        // Stop polling since WebSocket is now active
        stopProgressPolling();
        
        // Immediately fetch current progress when connected
        fetchCurrentProgress();
        
        // Fetch progress again in 2 seconds to catch any immediate updates
        setTimeout(fetchCurrentProgress, 2000);
    };

    websocket.onmessage = function(event) {
        const data = JSON.parse(event.data);
        handleProcessingUpdate(data);
    };

    websocket.onclose = function(event) {
        console.log('WebSocket connection closed', event.code, event.reason);
        
        if (event.code !== 1000) { // Not a normal closure
            document.getElementById('connectionStatus').textContent = 'Reconnecting...';
            document.getElementById('connectionStatus').className = 'badge bg-warning';
            addLogMessage('warning', 'Connection to processing server lost, attempting to reconnect...');
            
            // Start polling as fallback while reconnecting
            startProgressPolling();
            attemptReconnection();
        } else {
            document.getElementById('connectionStatus').textContent = 'Disconnected';
            document.getElementById('connectionStatus').className = 'badge bg-secondary';
            stopProgressPolling();
        }
    };

    websocket.onerror = function(error) {
        console.error('WebSocket error:', error);
        document.getElementById('connectionStatus').textContent = 'Error';
        document.getElementById('connectionStatus').className = 'badge bg-danger';
        addLogMessage('error', 'Connection error with processing server');
    };
}

function attemptReconnection() {
    if (reconnectAttempts >= maxReconnectAttempts) {
        addLogMessage('error', 'Maximum reconnection attempts reached. Please refresh the page.');
        document.getElementById('connectionStatus').textContent = 'Failed';
        document.getElementById('connectionStatus').className = 'badge bg-danger';
        return;
    }

    reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000); // Exponential backoff, max 30s
    
    addLogMessage('info', `Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} in ${delay/1000} seconds...`);
    
    reconnectInterval = setTimeout(() => {
        console.log(`Attempting WebSocket reconnection ${reconnectAttempts}/${maxReconnectAttempts}`);
        connectWebSocket();
    }, delay);
}

// Function to immediately fetch current progress
async function fetchCurrentProgress() {
    try {
        addLogMessage('info', 'Fetching current progress...');
        const response = await fetch(`/api/process/status/{{ manuscript_id }}`);
        if (!response.ok) {
            return;
        }

        const statusData = await response.json();
        const activeSession = statusData.active_session;

        if (activeSession) {
            if (!sessionId || sessionId !== activeSession.session_id) {
                sessionId = activeSession.session_id;
                const sessionIdEl = document.getElementById('sessionId');
                if (sessionIdEl) {
                    sessionIdEl.textContent = sessionId;
                }
            }

            if (activeSession.start_time && !startTime) {
                startTime = new Date(activeSession.start_time);
                const startTimeEl = document.getElementById('startTime');
                if (startTimeEl) {
                    startTimeEl.textContent = formatDateTime(startTime);
                }
            }

            if (activeSession.status) {
                const status = activeSession.status;
                updateProgress(status.progress || 0, status.message || 'Processing...');
                addLogMessage('success', `Current progress: ${status.progress || 0}%`);
                processingStarted = true;
                processingCompleted = false;
                processingFailed = false;
                updateProcessingStats(status);
                updateProcessingStatus(status.status, status.message || status.status);
            }

            restoreSessionLogs(activeSession);
            return;
        }

        const lastSession = statusData.last_session && (!sessionId || statusData.last_session.session_id === sessionId)
            ? statusData.last_session
            : null;

        if (lastSession) {
            if (!sessionId || sessionId !== lastSession.session_id) {
                sessionId = lastSession.session_id;
                const sessionIdEl = document.getElementById('sessionId');
                if (sessionIdEl) {
                    sessionIdEl.textContent = sessionId;
                }
            }

            if (lastSession.start_time && !startTime) {
                startTime = new Date(lastSession.start_time);
                const startTimeEl = document.getElementById('startTime');
                if (startTimeEl) {
                    startTimeEl.textContent = formatDateTime(startTime);
                }
            }

            const status = lastSession.status || {};
            const statusLabel = status.message || status.status || 'Processing update';

            updateProgress(status.progress || 0, statusLabel);
            updateProcessingStatus(status.status || 'completed', statusLabel);
            updateProcessingStats(status);
            restoreSessionLogs(lastSession);

            const finalState = status.status || 'completed';
            const wasFailed = processingFailed;

            if (finalState === 'completed') {
                if (!processingCompleted) {
                    addLogMessage('success', statusLabel);
                }
                processingCompleted = true;
                processingFailed = false;
            } else if (finalState === 'error') {
                processingCompleted = false;
                processingFailed = true;
                if (!wasFailed) {
                    showError(status.error || status.message || 'Processing failed to start.');
                }
            } else {
                processingCompleted = true;
                processingFailed = false;
            }

            processingStarted = false;
            return;
        }

        addLogMessage('warning', 'No active session found for this manuscript');
        updateProgress(0, 'No active processing session');
        processingStarted = false;

        if (!processingCompleted && !processingFailed && !isStartingSession) {
            addLogMessage('info', 'Attempting to start a new processing session...');
            startProcessingRequest();
        }
    } catch (error) {
        console.error('Error fetching current progress:', error);
        addLogMessage('warning', 'Could not fetch current progress');
    }
}

// Function to start continuous progress polling as fallback
function startProgressPolling() {
    // Clear any existing polling
    if (processingInterval) {
        clearInterval(processingInterval);
    }
    
    // Poll every 3 seconds when WebSocket is not working
    processingInterval = setInterval(async () => {
        if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            addLogMessage('info', 'WebSocket disconnected, polling for progress...');
            await fetchCurrentProgress();
        }
    }, 3000);
    
    addLogMessage('info', 'Started progress polling fallback (every 3 seconds)');
}

// Function to stop progress polling
function stopProgressPolling() {
    if (processingInterval) {
        clearInterval(processingInterval);
        processingInterval = null;
        addLogMessage('info', 'Stopped progress polling');
    }
}

function handleProcessingUpdate(data) {
    if (data.type === 'progress') {
        updateProgress(data.progress, data.message);
        
        updateProcessingStats(data);
    } else if (data.type === 'step') {
        updateProcessingStep(data.step, data.status);
    } else if (data.type === 'image') {
        addGeneratedImage(data.image_url, data.prompt);
    } else if (data.type === 'error') {
        showError(data.error);
    } else if (data.type === 'complete') {
        handleProcessingComplete(data);
    } else if (data.type === 'log') {
        addLogMessage(data.level, data.message);
    } else if (data.type === 'endpoint_paused') {
        showEndpointPauseAlert(data.message, data.countdown_seconds);
    } else if (data.type === 'endpoint_countdown') {
        updateCountdownTimer(data.countdown_seconds, data.message);
    }
}

function updateProgress(percentage, message) {
    console.log(`updateProgress called with: ${percentage}%, message: ${message}`);
    const progressBar = document.getElementById('overallProgress');
    const progressPercent = document.getElementById('progressPercent');
    const currentTask = document.getElementById('currentTask');

    progressBar.style.width = `${percentage}%`;
    progressPercent.textContent = `${percentage}%`;

    if (message) {
        currentTask.textContent = message;
    }
}

function updateProcessingStep(stepIndex, status) {
    const steps = document.querySelectorAll('#processingSteps .list-group-item');
    if (steps[stepIndex]) {
        const icon = steps[stepIndex].querySelector('i');
        const statusText = steps[stepIndex].querySelector('small');

        icon.className = 'bi me-2 ' + (
            status === 'completed' ? 'bi-check-circle-fill text-success' :
            status === 'processing' ? 'bi-arrow-clockwise text-primary' :
            status === 'error' ? 'bi-x-circle-fill text-danger' :
            'bi-circle text-muted'
        );

        statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        statusText.className =
            status === 'completed' ? 'text-success' :
            status === 'processing' ? 'text-primary' :
            status === 'error' ? 'text-danger' :
            'text-muted';
    }
}

function addGeneratedImage(imageUrl, prompt, skipIncrementCounter = false) {
    const imagesList = document.getElementById('imagesList');
    const imagesPreview = document.getElementById('imagesPreview');

    const imageCol = document.createElement('div');
    imageCol.className = 'col-md-3 mb-3';
    imageCol.innerHTML = `
        <div class="card">
            <img src="${imageUrl}" class="card-img-top" alt="Generated image" style="height: 200px; object-fit: cover;">
            <div class="card-body p-2">
                <small class="text-muted">${escapeHtml(prompt)}</small>
            </div>
        </div>
    `;

    imagesList.appendChild(imageCol);
    imagesPreview.style.display = 'block';

    // Update counter only for new images (not when restoring session)
    if (!skipIncrementCounter) {
        const nextCount = (statsState.imagesGenerated ?? 0) + 1;
        updateProcessingStats({ imagesGenerated: nextCount });
    }
}

function addLogMessage(level, message) {
    const log = document.getElementById('processingLog');
    const timestamp = new Date().toLocaleTimeString();

    const levelColors = {
        'info': 'text-info',
        'success': 'text-success',
        'warning': 'text-warning',
        'error': 'text-danger'
    };

    const logEntry = document.createElement('div');
    logEntry.innerHTML = `
        <span class="text-muted">[${timestamp}]</span>
        <span class="${levelColors[level] || 'text-light'}">[${level.toUpperCase()}]</span>
        ${escapeHtml(message)}
    `;

    log.appendChild(logEntry);

    if (sessionId) {
        log.dataset.sessionId = sessionId;
    }

    if (autoScroll) {
        log.scrollTop = log.scrollHeight;
    }
}

function restoreLogMessage(timestamp, level, message) {
    const log = document.getElementById('processingLog');

    // Parse the timestamp to display local time
    const date = new Date(timestamp);
    const displayTime = date.toLocaleTimeString();

    const levelColors = {
        'info': 'text-info',
        'success': 'text-success',
        'warning': 'text-warning',
        'error': 'text-danger'
    };

    const logEntry = document.createElement('div');
    logEntry.innerHTML = `
        <span class="text-muted">[${displayTime}]</span>
        <span class="${levelColors[level] || 'text-light'}">[${level.toUpperCase()}]</span>
        ${escapeHtml(message)}
    `;

    log.appendChild(logEntry);
}

function restoreSessionLogs(session) {
    if (!session || !Array.isArray(session.logs) || session.logs.length === 0) {
        return;
    }

    const log = document.getElementById('processingLog');
    if (!log) {
        return;
    }

    if (log.getAttribute('data-session-id') === session.session_id) {
        return;
    }

    log.innerHTML = '';
    session.logs.forEach(logEntry => {
        restoreLogMessage(logEntry.timestamp, logEntry.level, logEntry.message);
    });
    log.setAttribute('data-session-id', session.session_id);
}

function updateProcessingStatus(status, label) {
    const statusBadge = document.getElementById('processingStatus');
    const spinner = document.getElementById('processingSpinner');
    const restartBtn = document.getElementById('restartBtn');

    statusBadge.textContent = label;
    statusBadge.className = 'badge ' + (
        status === 'completed' ? 'bg-success' :
        status === 'error' ? 'bg-danger' :
        status === 'paused' ? 'bg-warning' :
        status === 'cancelled' ? 'bg-secondary' :
        'bg-primary'
    );

    if (status === 'completed' || status === 'error') {
        spinner.style.display = 'none';
    } else if (status === 'cancelled') {
        spinner.style.display = 'none';
    } else {
        spinner.style.display = 'inline-block';
    }

    // Show restart button only for cancelled status
    if (status === 'cancelled') {
        restartBtn.classList.remove('d-none');
    } else {
        restartBtn.classList.add('d-none');
    }
}

function startTimeTracking() {
    processingInterval = setInterval(() => {
        if (startTime) {
            const elapsed = new Date() - startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('elapsedTime').textContent =
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
    }, 1000);
}

function toggleAutoScroll() {
    autoScroll = !autoScroll;
    const btn = document.getElementById('autoScrollBtn');
    if (autoScroll) {
        btn.className = 'btn btn-success text-white';
        btn.innerHTML = '<i class="bi bi-arrow-down"></i> Auto-scroll ON';
    } else {
        btn.className = 'btn btn-info text-white';
        btn.innerHTML = '<i class="bi bi-arrow-down"></i> Auto-scroll';
    }
}

function clearLog() {
    const log = document.getElementById('processingLog');
    log.innerHTML = '<div class="text-muted">Log cleared...</div>';
    log.removeAttribute('data-session-id');
}

let logMaximized = false;

function toggleMaximizeLog() {
    const log = document.getElementById('processingLog');
    const btn = document.getElementById('maximizeLogBtn');

    if (!logMaximized) {
        // Maximize: double the height
        log.style.height = '600px';
        btn.className = 'btn btn-success';
        btn.innerHTML = '<i class="bi bi-arrows-collapse"></i> Minimize';
        logMaximized = true;
    } else {
        // Minimize: return to original height
        log.style.height = '300px';
        btn.className = 'btn btn-primary';
        btn.innerHTML = '<i class="bi bi-arrows-fullscreen"></i> Maximize';
        logMaximized = false;
    }
}

async function pauseProcessing() {
    if (!currentSessionId) {
        addLogMessage('error', 'No active processing session to pause');
        return;
    }

    const pauseBtn = document.getElementById('pauseBtn');
    if (pauseBtn.disabled) return;

    try {
        pauseBtn.disabled = true;
        pauseBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Pausing...';

        const response = await fetch(`/api/process/${currentSessionId}/pause`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        const result = await response.json();

        if (response.ok && result.success) {
            addLogMessage('info', result.message);
            // Update button to show resume option
            pauseBtn.innerHTML = '<i class="bi bi-play"></i> Resume';
            pauseBtn.onclick = resumeProcessing;
            pauseBtn.disabled = false;
        } else {
            addLogMessage('error', result.detail || 'Failed to pause processing');
            pauseBtn.innerHTML = '<i class="bi bi-pause"></i> Pause';
            pauseBtn.disabled = false;
        }
    } catch (error) {
        console.error('Error pausing processing:', error);
        addLogMessage('error', 'Network error while pausing processing');
        pauseBtn.innerHTML = '<i class="bi bi-pause"></i> Pause';
        pauseBtn.disabled = false;
    }
}

async function resumeProcessing() {
    if (!currentSessionId) {
        addLogMessage('error', 'No paused session to resume');
        return;
    }

    const pauseBtn = document.getElementById('pauseBtn');
    if (pauseBtn.disabled) return;

    try {
        pauseBtn.disabled = true;
        pauseBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Resuming...';

        const response = await fetch(`/api/process/${currentSessionId}/resume`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        const result = await response.json();

        if (response.ok && result.success) {
            addLogMessage('success', result.message);
            // Update button back to pause
            pauseBtn.innerHTML = '<i class="bi bi-pause"></i> Pause';
            pauseBtn.onclick = pauseProcessing;
            pauseBtn.disabled = false;
        } else {
            addLogMessage('error', result.detail || 'Failed to resume processing');
            pauseBtn.innerHTML = '<i class="bi bi-play"></i> Resume';
            pauseBtn.disabled = false;
        }
    } catch (error) {
        console.error('Error resuming processing:', error);
        addLogMessage('error', 'Network error while resuming processing');
        pauseBtn.innerHTML = '<i class="bi bi-play"></i> Resume';
        pauseBtn.disabled = false;
    }
}

function restartProcessing() {
    // Show confirmation dialog
    if (confirm('This will restart the processing from the beginning. Current progress will be lost. Are you sure?')) {
        addLogMessage('info', 'Restarting processing...');
        
        const restartBtn = document.getElementById('restartBtn');
        restartBtn.disabled = true;
        restartBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Restarting...';
        
        // Call the restart API endpoint
        fetch(`/api/process/${currentSessionId}/restart`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(result => {
            if (result.success) {
                addLogMessage('success', 'Processing restarted successfully.');
                restartBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Restart';
                restartBtn.disabled = false;
            } else {
                addLogMessage('error', result.detail || 'Failed to restart processing.');
                restartBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Restart';
                restartBtn.disabled = false;
            }
        })
        .catch(error => {
            console.error('Error restarting processing:', error);
            addLogMessage('error', 'Network error while restarting processing.');
            restartBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Restart';
            restartBtn.disabled = false;
        });
    }
}

async function cancelProcessing() {
    if (confirm('Are you sure you want to cancel processing? This action cannot be undone.')) {
        try {
            // First call the API to cancel processing on the server
            const response = await fetch(`/api/process/${sessionId}/cancel`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.detail || 'Failed to cancel processing');
            }
            
            // Close the websocket after the cancel request is sent
            if (websocket) {
                websocket.close();
            }
            
            // Update UI
            updateProcessingStatus('cancelled', 'Cancelled');
            addLogMessage('warning', 'Processing cancelled by user');
            
            // Disable cancel button and enable restart
            document.getElementById('cancelBtn').disabled = true;
            document.getElementById('restartBtn').classList.remove('d-none');
            
        } catch (error) {
            console.error('Error cancelling processing:', error);
            addLogMessage('error', `Failed to cancel processing: ${error.message}`);
        }
    }
}

function retryProcessing() {
    window.location.reload();
}

async function restartProcessing() {
    if (!confirm('Are you sure you want to restart processing? This will reset the current progress and start over.')) {
        return;
    }

    try {
        const response = await fetch(`/api/process/${sessionId}/restart`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || 'Failed to restart processing');
        }

        const result = await response.json();
        
        if (result.success) {
            addLogMessage('success', result.message || 'Processing restarted successfully');
            updateProcessingStatus('started', 'Starting...');
            
            // Reconnect WebSocket if needed
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                connectWebSocket();
            }
        } else {
            throw new Error(result.message || 'Failed to restart processing');
        }
    } catch (error) {
        addLogMessage('error', `Failed to restart processing: ${error.message}`);
        console.error('Restart error:', error);
    }
}

function handleProcessingComplete(data) {
    updateProcessingStatus('completed', 'Completed');
    updateProgress(100, 'Processing completed successfully');

    if (processingInterval) {
        clearInterval(processingInterval);
    }

    const totalFromEvent = data.total_chapters ?? data.totalChapters ?? null;
    const processedFromEvent = data.chapters_processed ?? data.chaptersProcessed ?? null;
    const finalChapterCount = processedFromEvent ?? statsState.chaptersProcessed ?? statsState.currentChapter ?? 0;

    updateProcessingStats({
        chaptersProcessed: finalChapterCount,
        totalChapters: totalFromEvent ?? statsState.totalChapters,
        imagesGenerated: data.images_count
    });

    addLogMessage('success', `Processing completed! Generated ${data.images_count || 0} images.`);
    processingStarted = false;
    processingCompleted = true;
    processingFailed = false;

    // Show completion message
    setTimeout(() => {
        if (confirm('Processing completed successfully! Would you like to view the results in the gallery?')) {
            window.location.href = `/manuscript/{{ manuscript_id }}/gallery`;
        }
    }, 2000);
}

function showError(error) {
    document.getElementById('errorDetails').textContent = error;
    new bootstrap.Modal(document.getElementById('errorModal')).show();
    updateProcessingStatus('error', 'Error');
    addLogMessage('error', error);
    processingFailed = true;
    processingStarted = false;
}

function formatDateTime(date) {
    return date.toLocaleString();
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Endpoint pause handling
function showEndpointPauseAlert(message, countdownSeconds) {
    const alertElement = document.getElementById('endpointPauseAlert');
    const messageElement = document.getElementById('endpointPauseMessage');
    const timerElement = document.getElementById('countdownTimer');
    
    // Show the alert
    alertElement.style.display = 'block';
    messageElement.textContent = message || 'The AI service endpoint is currently paused. Waiting for it to restart automatically...';
    timerElement.textContent = `Retrying in ${countdownSeconds} seconds...`;
    
    // Add log message
    addLogMessage('warning', `AI endpoint paused - waiting ${countdownSeconds} seconds for restart`);
    
    // Update processing status
    updateProcessingStatus('paused', 'Endpoint Paused');
}

function updateCountdownTimer(remainingSeconds, message) {
    const timerElement = document.getElementById('countdownTimer');
    const messageElement = document.getElementById('endpointPauseMessage');
    
    if (remainingSeconds <= 0) {
        // Hide the alert when countdown is done
        const alertElement = document.getElementById('endpointPauseAlert');
        alertElement.style.display = 'none';
        
        // Update processing status
        updateProcessingStatus('processing', 'Retrying...');
        addLogMessage('info', 'Endpoint wait period completed - attempting to resume processing');
    } else {
        // Update countdown display
        timerElement.textContent = `Retrying in ${remainingSeconds} seconds...`;
        if (message) {
            messageElement.textContent = message;
        }
        
        // Log countdown updates at 30-second intervals to avoid spam
        if (remainingSeconds % 30 === 0) {
            addLogMessage('info', `Still waiting for endpoint restart - ${remainingSeconds} seconds remaining`);
        }
    }
}

function hideEndpointPauseAlert() {
    const alertElement = document.getElementById('endpointPauseAlert');
    alertElement.style.display = 'none';
}

// Handle page navigation - enable background processing
window.addEventListener('beforeunload', function(e) {
    // Don't prevent navigation but enable background mode
    enableBackgroundProcessing();
});

function enableBackgroundProcessing() {
    if (currentSessionId && currentManuscriptId) {
        // Store session info for floating status window
        sessionStorage.setItem('processingSession', JSON.stringify({
            sessionId: currentSessionId,
            manuscriptId: currentManuscriptId,
            manuscriptTitle: '{{ manuscript_metadata.title if manuscript_metadata else "Unknown" }}',
            timestamp: Date.now()
        }));
        
        // Notify floating status manager
        if (window.attachToProcessingSession) {
            window.attachToProcessingSession(
                currentSessionId, 
                currentManuscriptId, 
                '{{ manuscript_metadata.title if manuscript_metadata else "Processing Session" }}'
            );
        }
        
        // Add background processing notification
        addLogMessage('info', 'Processing will continue in background. You can monitor progress from the floating status window.');
    }
    
    // Close WebSocket gracefully but don't terminate the session
    if (websocket) {
        websocket.close();
    }
    if (processingInterval) {
        clearInterval(processingInterval);
    }
}

// Add navigation helper
function navigateToPage(url) {
    enableBackgroundProcessing();
    window.location.href = url;
}

// Override default back button behavior
document.addEventListener('DOMContentLoaded', function() {
    // Update back button to enable background processing
    const backButton = document.querySelector('a[href^="/manuscript/"]');
    if (backButton) {
        backButton.addEventListener('click', function(e) {
            e.preventDefault();
            navigateToPage(this.href);
        });
    }
    
    // Check if this is a reconnection to an existing session
    const urlParams = new URLSearchParams(window.location.search);
    const sessionId = urlParams.get('session_id');
    if (sessionId) {
        // Clear floating status since we're now on the full page
        sessionStorage.removeItem('processingSession');
    }
});
</script>
{% endblock %}
